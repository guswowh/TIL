# javaScript 비동기

<br />

## - Qery String
  문법 | 내용
  --|--
  주소?속성=값&속성=값&속성=값 | url 주소에 미리 협의된 데이터를 파라미터를 통해 넘기는 것

<br />

## - request & response
  - 요청 후 응답을 받을 때가 언제인지 알 수 없다.

<br />

## - 싱글스레드(Single thread) = 동기 방식
  - 자바스크립트는 기본적으로 명령을 하나씩만 처리할 수 있다

<br />

## - 동기 방식
  - 요청 후 응답을 처리하고 다음 작업을 진행한다.

<br />

## - 비동기 방식
  - 요청 후 응답을 기다리지 않고 다음 작업을 진행한다.

    > fatch & then
      - fatch : 요청 함수
      - then : 응답 함수

        > 예제
        ```js
        fetch('https://omdbapi.com/?apikey=7035c60c&s=frozen', {
            method: 'GET'
          })
          .then(res => res.json()) // 필수 : 네트워크에서 JSON 파일을 파싱한다.
          .then(res => {
            console.log(res)
          })
        ```
    
    <br />

    > axios & then : [axios](https://cdnjs.com/libraries/axios) 라이브러리 설치 필요
      - axios : 요청 함수
      - then : 응답 함수

        > 패턴
        ```js
        axios({
          url: 'https://omdbapi.com/?apikey=7035c60c&s=frozen',
          method: 'GET'
        })
          .then({ data }] => {console.log(data)})
        ```

<br>

## - async & await 패턴
  - fetch의 콜백지옥으로 읽기 힘든 페턴을 동기방식처럼 표현하여 가독성을 높인다.
    > async & await of fatch
      - async : await 함수를 사용하기 위한 함수선언
      - await fatch :  요청 처리 후 동장 함수

        > 예제
        ```js
        async function getMovie() {
          let res = await fatch('https://omdbapi.com/?apikey=7035c60c&s=frozen', {
            method: 'GET'
          })
          res = await res.json()
          console.log(res)
        }
        getMovie()
        ```
    <br />

    > async & await of axios : "axios" 라이브러리 설치 필요
      - async : await 함수를 사용하기 위한 함수선언
      - await axios : 요청 처리 후 동장 함수

        > 예제
        ```js
        async function getMovie() {
          const res = axios({
            url: 'https://omdbapi.com/?apikey=7035c60c&s=frozen',
            method: 'GET'
          })
        }
        getMovie()
        ```
## - 프로미스(promise)
  - 비동기 작업시 응답을 처리하기 위하여 사용
  
  > 프로미스 객체(프로미스 인스턴스)
  - 프로미스가 반환한 객체 데이터
  - 반환된 프로미스 인스턴스를 통하여 fatch, async & await 패턴을 사용 할 수 있다.
  
  > 대기 이행 상태
  - 대기 : 초기상태
  - 이행 : 연산성공, 완료
  - 거부 : 연산 실패

  > 예제
  ```js
  function getMovie() {
    // promise instance
    return new Promise(resolve => { 
      fetch('https://omdbapi.com/?apikey=7035c60c&s=frozen')
        .then(res => res.json())
        .then(res => {
          resolve(res)
        })
    })
  }

  getMovie().then(res => console.log(res))

  ;(async function () {
    const res = await getMovie()
    console.log(res)
  })()
  ```



<br>

## - 비동기로 이미지를 처리하는 예
  - 상황
    1. 해상도가 높은 이미지를 로드 해야하는 상황
    2. 데이터를 처리하는 시간동안 다음 명령을 실행하지 못한다.
    <br /><br />
  - 비동기 방식으로 데이터를 처리하여 다음 명령을 실행한다. 

    ```js
    function imageLoad(src) {
      return new Promise(resolve => {
        const imgEl = document.createElement('img')
        imgEl.src = src
        imgEl.addEventListener('load', () => {
          resolve()
        })
      })
    }

    const imgConatiner = document.querySelector('.image')

    imageLoad('https://gstatic.com/webp/gallery/1.jpg')
      .then(() => {
        console.log('Done!')
        imgConatiner.classList.add('done')
      })

    ;(async function () {
      await imageLoad('https://gstatic.com/webp/gallery/1.jpg')
      console.log('Done!')
      imgConatiner.classList.add('done')
    })()
    ```
    > [codePen](https://codepen.io/bbxkoulf/pen/YzePrdN?editors=1111)

<br />

## - 예외사항 처리
  - try & catch & finally 문

    문법 | 설명
    --|--
    try | 에러가 발생할 수 있는 코드 영역
    catch | 에러 발생시 처리
    finally | 최종적으로 마지막에 무조건 실행

    `*` finally 사용 예) 실행되고 있는 함수를 종료 하기 위한 용도로 사용

    <br />

    > .then / async & await 패턴
    ```js
    // .hten
    .then()
    .catch()
    .finally()

    // async / await
    try { 

    } catch (err) { 

    } finally { 

    }
    ```

    > async & await 예제
    ```js
    async function getMovie() {
      try {
        let res = await fetch('https://omdbapi.com123/?apikey=7035c60c&s=frozen')
        res = await res.json()
        console.log(res)
        return res
      } catch (guswowh) {
        alert('에러가 발생했어요!')
      } finally {
        console.log('실행 완료!')
      }
    }

    const res = getMovie()
    console.log(res)
    ```

    > .then 예제
    ```js
    function getMovie() {
      fetch('https://omdbapi.com123/?apikey=7035c60c&s=frozen')
        .then(res => res.json())
        .then(res => res)
        .catch(error => alert('~~~~'))
        .finally(() => { console.log('Done!')})
    }

    const res = getMovie()
    console.log(res)
    ```
    > [codepen](https://codepen.io/bbxkoulf/pen/qBxExXB?editors=0011)

<br />

## - promise.all
  - 프로미스의 정적 메소드
  
  - promise.all 과 .then

    > promise.all
    - 병렬방식 : 함수를 시작과 동시에 전부 실행한 결과 값을 반환한다. (조금 빠르다)
    <br /><br />
    > .then
    - 직렬방식 : 함수를 차례대로 실행한 결과 값을 반환한다. (조금 느리다)
    ```js
    // 병렬방식
    function getMovie() {
      Promise.all([
        fetch('https://omdbapi.com/?apikey=7035c60c&s=frozen')
          .then(res => res.json()),  
        fetch('https://omdbapi.com/?apikey=7035c60c&s=ironman')
          .then(res => res.json())
      ])
        .then(res => {
          console.log('fetch1:', res[0])
          console.log('fetch2:', res[1])
          console.log('Done!')
        })
    }

    // 직렬방식
    async function getMovie() {
      const res1 = await fetch('https://omdbapi.com/?apikey=7035c60c&s=frozen')
          .then(res => res.json())
      const res2 = await fetch('https://omdbapi.com/?apikey=7035c60c&s=frozen')
          .then(res => res.json())

      console.log('async1:', res1)
      console.log('async2:', res2)
      console.log('Done!')
    }

    getMovie()
    ```

<br />

## - promise 함수의 매개변수 

<br />

> promise.resolv
  - 프로미스 인스턴스를 만드는 정적 메소드

<br />

> promise.rejeck
  - 비동기 처리를 거부 할 수 있다.

> 예제
```js
function imageLoad(src) {
  return new Promise((resolve, reject) => {
    if (!src) {
      reject('이미지 경로 없는디?')
      return
    }
    const imgEl = document.createElement('img')
    imgEl.src = src
    imgEl.addEventListener('load', () => {
      resolve('이미지 로드 완료!')
    })
  })
}

imageLoad()
  .then(res => {
    console.log(res)
  })
  .catch(error => {
    console.log(error)
  })
```